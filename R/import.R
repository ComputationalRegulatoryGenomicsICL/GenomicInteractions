# import methods

#' Function to process names relating to interactions stored in bed12 formats.
#' 
#' In bed(n) formats interaction data cannot be stored directly due to the inability of the format to handle
#' trans-interactions. It is only capable of storing cis-interactions through the use of blockStarts and blockEnds.
#' As such the information is typically stored as a string of the format chr1:start1..end1-chr2:start2..end2,N
#' (e.g. \"chr1:3268539..3269061-chr10:103124111..103124631,4\".). This function takes a vector of these strings 
#' and converts them to a data.frame.
#' 
#' @param x a vector of names stored in the bed file
#' 
#' @return a data.frame containing all of the processed information
#'  
#' @importFrom stringr str_split
.processChiapetName = function(x){
  tmp.str = str_split(x, ",")
  counts = as.integer(unlist(lapply(tmp.str, function(y){ return(y[2] ) } )))
  tmp.str.2 = sapply(tmp.str, function(y){
    str_split(y[1], "-")
  })
  paired.end.1 = t(sapply(tmp.str.2, function(y){
    tmp = str_split(y[[1]], ":")
    chr = tmp[[1]][1]
    tmp = str_split(tmp[[1]][2], "\\.\\.")
    start = as.integer(tmp[[1]][1]) + 1
    end = as.integer(tmp[[1]][2])
    return(c(chr, start, end))
  }))
  paired.end.2 = t(sapply(tmp.str.2, function(y){
    tmp = str_split(y[[2]], ":")
    chr = tmp[[1]][1]
    tmp = str_split(tmp[[1]][2], "\\.\\.")
    start = as.integer(tmp[[1]][1]) + 1
    end = as.integer(tmp[[1]][2])
    return(c(chr, start, end))
  }))
  dat = cbind(paired.end.1, paired.end.2, counts)
  colnames(dat) = c("chrom.left.", "start.left.", "end.left.", "chrom.right.", "start.right.", "end.right.", "counts")
  return(dat)
}


#' Function to read in processed Hi-C interaction data generated by HOMER
#' 
#' This function reads in the interaction data outputted by HOMER (http://homer.salk.edu/homer/interactions/). 
#' 
#' @param fn location of data exported by HOMER
#' @return a data frame containing the relevant information
#' 
.importHomer = function(fn){
  HOMER_int.df <- read.table(fn, header=TRUE, stringsAsFactors=FALSE, sep="\t")
  #convert to closed format
  #already 1-based
  HOMER_int.df$end.1. <- HOMER_int.df$end.1. - 1
  HOMER_int.df$end.2. <- HOMER_int.df$end.2. - 1
  return(HOMER_int.df)
}


#' Function to read in processed Hi-C interaction data generated by hiclib
#' 
#' This function reads in the interaction data processed by [hiclib](https://bitbucket.org/mirnylab/hiclib). The data is extracted from hiclib and 
#' exported from its internal HDF5 format to text using h5dictToTxt.py. This function reads in the relevant files present in the 
#' directory and generates a data.table containing all of the information. It assumes that there are files with the following
#' names in the directory: fragids1, chrms1, mids1, fraglens1, fragids2, chrms2, mids2, fraglens2, distances. 
#' 
#' @param dir directory containing the output files generated by hiclib, extracted using h5dictToTxt.py
#' @param genome BSGenome to use for constructing the GenomicInteractions object.
#' @return data.table containing information on the individual interactions
#' 
#' @import data.table
#'
.importHicLib = function(dir, genome){
  
  .process.chr = function(chrs, genome){
    
    chrs = as.numeric(chrs)+1
    chrs = ifelse( names(seqlengths(genome)[chrs]) %in% c("chrY"), "Y", chrs)
    chrs = ifelse( names(seqlengths(genome)[chrs]) %in% c("chrX"), "X", chrs)
    return( paste0("chr", chrs ))
  }
  
  frags=data.table(fragid1=fread(paste0(dir, "fragids1"))$V1, chrm1=.process.chr(fread(paste0(dir, "chrms1"))$V1, genome), 
                   mid1=fread(paste0(dir, "mids1"))$V1, fraglength1 = fread(paste0(dir, "fraglens1"))$V1,
                   fragid2=fread(paste0(dir, "fragids2"))$V1, chrm2=.process.chr(fread(paste0(dir, "chrms2"))$V1, genome),
                   mid2=fread(paste0(dir, "mids2"))$V1, fraglength2 = fread(paste0(dir, "fraglens2"))$V1,
                   distances=fread(paste0(dir, "distances"))$V1, stringsAsFactors=FALSE)
  frags_agg <- frags[, .N, by=names(frags)]
  
  return(frags_agg)
}


#' Function to read in interaction-data stored in a BAM file
#' 
#' Reads in interactions stored in a BAM file. Assumes that each interaction is represented by pair of PETs 
#' with the same qname. The function reads in and determines which anchor is which by examining the 
#' isFirstMateRead and isSecondMateRead fields in the BAM file. 
#' 
#' @param fn name of BAM file containing interaction information
#' @param genome BSGenome to use for constructing the GenomicInteractions object.
#' @return list of GRanges - storing the anchor information for each interaction
#'  
#' @importFrom Rsamtools scanBamFlag ScanBamParam scanBam
#' @import GenomicRanges
#'
.readBam = function(fn, genome){
  bf = scanBamFlag(isPaired = TRUE, isDuplicate=FALSE)
  param = ScanBamParam(flag=bf, what=c("rname", "qname", "strand", "pos", "seq", "cigar", "flag") )
  b = scanBam(fn, param=param)
                  
  y = GRanges(b[[1]]$rname, IRanges(b[[1]]$pos, width=width(b[[1]]$seq)), strand = b[[1]]$strand,
                                                                              qname = b[[1]]$qname,
                                                                              bamFlagAsBitMatrix(b[[1]][["flag"]], bitnames="isFirstMateRead"), 
                                                                              bamFlagAsBitMatrix(b[[1]][["flag"]], bitnames="isSecondMateRead")    ,
                                                                              seqlengths=seqlengths(genome)
              ) 

  y1 = y[ y$isFirstMateRead == 1 ]
  y2 = y[ y$isSecondMateRead == 1]

  y1 = y1[ y1$qname %in% unique(y1$qname)]
  y2 = y2[ y2$qname %in% unique(y2$qname)]
  
  y1 = y1[ order(y1$qname) ]
  y2 = y2[ order(y2$qname) ]
  y1$isFirstMateRead = NULL
  y1$isSecondMateRead = NULL
  y2$isSecondMateRead = NULL
  y2$isFirstMateRead = NULL
  return(list(y1, y2))

}
